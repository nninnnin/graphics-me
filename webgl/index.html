<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <canvas></canvas>

    <script>
      const canvas = document.querySelector("canvas");

      const gl = canvas.getContext("webgl");

      console.log(gl);
    </script>

    <script id="vertex-shader-2d" type="x-shader/x-vertex" type="notjs">
      // an attribute will receive data from a buffer
      attribute vec4 a_position;

      // all shaders have a main function
      void main () {
        // l_Position is a special variable a vertex shader is resposible for setting
        gl_Position = a_position;
      }
    </script>

    <script id="fragment-shader-2d" type="x-shader/x-fragment" type="notjs">
      // fragment shaders don't have a default precision so we need to pick one.
      // mediump is a good default
      precision mediump float;

      void main () {
        // gl_FragColor is a special variable a fragment shader is resposible for setting
        gl_FragColor = vec4(1, 0, 0.5 ,1); // return reddish-purple
      }
    </script>

    <script>
      function createShader(gl, type, source) {
        var shader = gl.createShader(type); // 타입에 맞는 셰이더 인스턴스 생성

        gl.shaderSource(shader, source); // 셰이더 인스턴스에 셰이더코드(소스) 바인딩
        gl.compileShader(shader); // 셰이더를 컴파일

        var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

        console.log("쉐이더 컴파일에 성공했나요..?", success);

        if (success) {
          return shader;
        }

        const msg = gl.getShaderInfoLog(shader);
        console.log("LOG: ", msg);

        gl.deleteShader(shader);
      }
    </script>

    <script>
      const vertexShaderSource =
        document.getElementById("vertex-shader-2d").text;
      const fragmentShaderSource =
        document.getElementById("fragment-shader-2d").text;

      const vertexShader = createShader(
        gl,
        gl.VERTEX_SHADER,
        vertexShaderSource
      );

      const fragmentShader = createShader(
        gl,
        gl.FRAGMENT_SHADER,
        fragmentShaderSource
      );

      console.log(vertexShader);
    </script>

    <script>
      function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();

        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        const success = gl.getProgramParameter(program, gl.LINK_STATUS);

        if (success) {
          return program;
        }

        console.log(gl.getProgramInfoLog(program));

        gl.deleteProgram(program);
      }
    </script>

    <script>
      const program = createProgram(gl, vertexShader, fragmentShader);

      console.log(program);

      const positionAttributeLocation = gl.getAttribLocation(
        program,
        "a_position"
      );

      // `positionBuffer` 라는 버퍼를 만든다
      const positionBuffer = gl.createBuffer();

      // ARRAY_BUFFER를 바인딩한다
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

      const positions = [0, 0, 0, 0.5, 0.7, 0];

      // ARRAY_BUFFER에 새로운 포지션 값을 넘겨준다
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(positions),
        gl.STATIC_DRAW // hint to WebGL about how we'll use the data. WebGL can try to use that hint to optimize certain things. `gl.STATIC_DRAW` tells WebGL we are not likely to change this data much.
      );
    </script>
  </body>
</html>
